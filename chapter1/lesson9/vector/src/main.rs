fn print_vec(v: &Vec<i32>) { // можно заимствовать
    for i in 0..v.len() {
        println!("{}", v[i]);
    }
}

fn main() {
    // Пустой вектор (нужно указать тип)
    let mut v1: Vec<i32> = Vec::new();

    // Макрос vec! для удобного создания с начальными значениями
    let v2 = vec![1, 2, 3];           // Vec<i32>
    let v3 = vec![0; 5];              // [0, 0, 0, 0, 0] - пять нулей

    // Можно создать из диапазона (Range), но это неявно использует итераторы – пока не будем.

    let mut v = Vec::new();
    v.push(10);      // добавляет в конец
    v.push(20);      
    println!("{:?}", v); // [10, 20]

    let last = v.pop();   // удаляет последний элемент, возвращает Option<T>
    println!("{:?}", last); // Some(20)
    println!("{:?}", v);   // [10]

    v.push(30);
    v.push(40);

    let v = vec![10, 20, 30];

    // По индексу – паникует, если индекс вне диапазона
    let first = v[0];     // 10

    // Безопасный доступ – возвращает Option<&T>
    let second = v.get(1); // Some(&20)
    let none = v.get(5);   // None

    for i in 0..v.len() {
        println!("{}", v[i]);
    }

    let s = String::from("hello");
    let v = vec![s];        // s перемещается в вектор
    // println!("{}", s);   // ОШИБКА: s больше не владеет значением
    // Вектор владеет своими элементами. Когда вы помещаете значение в вектор, оно перемещается (если тип не Copy).

    let mut v = vec![10, 20, 30];
    v[1] = 25;              // работает, потому что i32 реализует Copy

    print_vec(&v);
}
